<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <meta name="Author" content="Sergey Melnik">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
   <title>Storing RDF in a relational database</title>
</head>
<body alink="#FF0000" link="#0000EE" text="#000000" vlink="#551A8B" bgcolor="#FFFFFF">

<h1>
Storing RDF in a relational database</h1>
This page summarizes some current approaches to storing RDF in a relational
database. <b>THIS IS A REQUEST FOR COMMENTS</b>, so please do contribute
your ideas (<a href="mailto:www-rdf-interest@w3.org">www-rdf-interest@w3.org</a>)!
To goal is to come up with the best way of storing RDF in a relational
database, or identify a set of solutions that are suitable for particular
needs.
<h2>
Motivation</h2>
We need to be able to persistently store and manipulate (large amounts
of) RDF data. One of the alternatives to do that is to use the relational
database technology. A major advantage of this approach is that is provides
a scalable off-the-shelf solution.
<h2>
Criteria</h2>
A non-exhaustive list of the criteria to be considered for the database
schema design (in no particular order):
<ul>
<li>
Scalability: can we store and query 1B+ triples?</li>

<li>
Querying: what kind of queries are supported? can they be easily formulated
and processed?</li>

<li>
Efficiency: how expensive are the queries? what are the costs of delivering
the result?</li>

<li>
Optimization: how can we handle reification?</li>

<li>
Organization: what is the overhead associated with storing the data? can
we distinguishably mix RDF models still being able to determine where the
triples come from?</li>
</ul>
The proposals shown below satisfy the above criteria in different ways.
The maintainer of this page is particularly interested in addressing the
scalability issue. Please submit other criteria reflecting your needs!

<h2>Publications</h2>

The following paper discusses a vertical scheme for storing and
querying sparse relational tables, which is similar in spirit to some
of the proposals below:

<p>

R. Agrawal, A. Somani, and Y. Xu: <i>Storage and Querying of
E-Commerce Data</i>, Proc. VLDB 2001, Roma, Italy, available as <a href="http://www.vldb.org/conf/2001/P149.pdf">http://www.vldb.org/conf/2001/P149.pdf</a>

</p><h2>
Database schemas for storing RDF</h2>
(most recently contributed first)

<h3>
<a name="loyal"></a>Explicit models</h3>

<table border="" cellpadding="5">
<tbody><tr valign="TOP">
<td>Contributed by:</td>

<td><a href="mailto:bwm@hplb.hpl.hp.com">Brian McBride</a></td>
</tr>

<tr valign="TOP">
<td>Date:</td>

<td>May 11, 2000</td>
</tr>

<tr valign="TOP">
<td>Brief summary:</td>

<td>This representation treats models explicitly and makes use of views</td>
</tr>

<tr valign="TOP">
<td>Database schema (Oracle) and description by the author:</td>
<td><pre>                sql = "CREATE TABLE RDFRESOURCE"
                        + "("
                        +   "Id INTEGER not null primary key,"
                        +   "NS INTEGER not null,"
                        +   "RoName varchar(255)"
                        + ")";

The resource table holds all resources.  Id is an internal
identifier field.  NS is a pointer to an entry in the namespace
table giving the namespace for this resource.  RoName should be
called 'localname' and is the local name component of the Qname.


                sql = "CREATE TABLE RDFNameSpace"
                        + "("
                        +   "Id INTEGER not null primary key,"
                        +   "NsName varchar(255)"
                        + ")";

The namespace table.
                               
                sql = "CREATE TABLE RDFLiteral"
                        + "("
                        +   "Id INTEGER not null primary key,"
                        +   "VAL varchar (4000)"
                        + ")";

Table of literals.  4000 character limit is enough for current purposes.
                
                
                sql = "CREATE TABLE RDFStatement"
                        + "("
                        +   "Id INTEGER not null primary key,"
                        +   "Subject INTEGER not null,"
                        +   "Predicate INTEGER not null,"
                        +   "ObjResource INTEGER not null,"
                  +   "ObjLiteral INTEGER not null,"
                        +   "Res CHAR(1) not null"
                        + ")";

Statement table.  Originally had a single object field which
would have the ID of either an object or a literal.  A
complicated JOIN expression is used to enumerate a list of
statements and was behaving unexpectedly.  My inexperience
with SQL probably.  This works and feels more 'correct'.  Res is
a flag to say whether the object is a resource or literal.
                
                sql = "CREATE TABLE RDFModel"
                        + "("
                        +   "ModelId INTEGER not null,"
                        +   "Statement INTEGER not null,"
                        +   "Asserted CHAR(1) not null,"
                        +   "Reified CHAR(1) not null,"
                        +   "primary key(ModelId, Statement)"
                        + ")";

The database can hold multiple models.  This table keeps a list of 
the statements in each model.  Originally this table was combined with
the statement table but that didn't work when it came to
implementing set operations. 

Asserted is a flag which says this statement is asserted in this model.
Reified is a flag which says this statement is reified in this model.
The latter is a hook for future implementation.  Reification isn't 
implemented so this approach is untested.

Each model is a resource and has an entry in the resource table.
The ModelId field is the Id of that resource.  Thus
statements can be made about the model.  There is a class for models
and it is possible to list the schemas that need to be loaded when
validating a model.
                
                sql = "CREATE OR REPLACE VIEW RootModel"
                     +  " AS SELECT UNIQUE Id, Subject, Predicate,
ObjResource, ObjLiteral, Res, Asserted, Reified"
                     +    " FROM RDFModel, RDFStatement"
                     +    " WHERE RDFModel.Statement = RDFStatement.Id";

This creates a view of an artificial model which contains all the statements
in the database, whatever 'actual' model they are in.

Views are heavily used.  Every model is a view which is a query onto either
another model view or the RootModel view.  So every time any operation in
the Stanford API which creates a model is called, e.g. any query, a new view
is created in the database.  This must lead to some bizarre queries being
fed to the database query engine, and I'm relying on its query optimiser to
sort those out.  There is also a problem with stale views being left around
in the database should an application crash.

                sql = "CREATE TABLE RDFKEYS"
                        + "("
                        +   "TableName char(10) not null primary key,"
                        +   "Key INTEGER not null"
                        + ")";
                sql = "INSERT INTO RDFKEYS (TableName, Key)
VALUES('Resource', 0)";
                sql = "INSERT INTO RDFKEYS (TableName, Key)
VALUES('NameSpace', 0)";

A key generation table.  Probably could use a sequencer, but they seem to be
a bit database specific and I started out at least with the intent not to
be. Only really need one generator though.

There was a question about schemas.  Right now, schemas are held as models
and can be fed into the schema validator.  No attempt has been made to use a
schema to define a more specific database structure.

</pre>
</td>

</tr><tr>
<td>Original posting:</td><td><a href="http://lists.w3.org/Archives/Public/www-rdf-interest/2000May/0094.html">http://lists.w3.org/Archives/Public/www-rdf-interest/2000May/0094.html</a></td>
</tr>

</tbody></table>

<h3>
<a name="loyal"></a>Specs loyal</h3>

<table border="" cellpadding="5">
<tbody><tr valign="TOP">
<td>Contributed by:</td>

<td><a href="mailto:jonas@paranormal.se">Jonas Liljegren</a></td>
</tr>

<tr valign="TOP">
<td>Brief summary:</td>

<td>An attempt to provide a compact way of implementing every detail in
the RDF model and schema specs.</td>
</tr>

<tr valign="TOP">
<td>Database schema (Postgres):</td>

<td><tt>CREATE TABLE statements</tt>
<br><tt>(</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 
id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pred&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; subj&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; obj&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fact&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int&nbsp;&nbsp;&nbsp; -- 0 if only a reified statement</tt>
<br><tt>);</tt>
<p><tt>-- If a statement referes to a nonexistent resource, it is taken
to be</tt>
<br><tt>-- an internal statement with the name local#nr, there local is
the</tt>
<br><tt>-- locale namespace and nr is the id number. But if there is a</tt>
<br><tt>-- statement with the same name, it is taken to be a reference
to the</tt>
<br><tt>-- reified statement.&nbsp;</tt>
</p><p><tt>CREATE TABLE resources</tt>
<br><tt>(</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 
id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uri&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
text,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
text,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; isprefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; lang&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
text</tt>
<br><tt>);</tt>
</p><p><tt>CREATE TABLE prefix</tt>
<br><tt>(</tt>
<br><tt>&nbsp;&nbsp;&nbsp; from&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 
to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int</tt>
<br><tt>);</tt>
</p><p><tt>CREATE SEQUENCE internal_id;</tt></p></td>
</tr>

<tr valign="TOP">
<td>Description:</td>

<td><a href="http://infolab.stanford.edu/%7Emelnik/rdf/db-jonas.html">by the author</a></td>
</tr>

</tbody></table>




<h3>
<a name="hashed"></a>Hashed with origin</h3>

<table border="" cellpadding="5">
<tbody><tr valign="TOP">
<td>Contributed by:</td>

<td><a href="mailto:melnik@db.stanford.edu">Sergey Melnik</a></td>
</tr>

<tr valign="TOP">
<td>Brief summary:</td>

<td>In this approach the main table <tt>triples</tt> stores only the CRC64
hash values of the resources and literals. Moreover, every triple has an
associated hash value of the URI where it came from (<tt>model</tt>). Resource
URIs are stored in the table <tt>resources</tt>, literals are stored in
<tt>literals</tt>.
Resources themselves are split into namespaces and names, the former being
stored as a CRC64 hashes. This scalability of this solution has been evaluated
against the <a href="http://dmoz.org/">Open Directory</a> data using <a href="http://www.mysql.com/">MySQL</a>.
The table <tt>models</tt> is optional in the sense that the metadata about
models could be stored in <tt>triples</tt> themselves.</td>
</tr>

<tr valign="TOP">
<td>Database schema (MySQL):</td>

<td><tt>CREATE TABLE triples (</tt>
<br><tt>&nbsp; model bigint(20) DEFAULT '0' NOT NULL,</tt>
<br><tt>&nbsp; subject bigint(20) DEFAULT '0' NOT NULL,</tt>
<br><tt>&nbsp; predicate bigint(20) DEFAULT '0' NOT NULL,</tt>
<br><tt>&nbsp; object bigint(20) DEFAULT '0' NOT NULL,</tt>
<br><tt>&nbsp; objtype tinyint(3) unsigned DEFAULT '0' NOT NULL,</tt>
<br><tt>&nbsp; KEY idx_subject_predicate (subject,predicate),</tt>
<br><tt>&nbsp; KEY idx_model (model),</tt>
<br><tt>&nbsp; KEY idx_object_predicate (object,predicate)</tt>
<br><tt>);</tt>
<p><tt>CREATE TABLE resources (</tt>
<br><tt>&nbsp; hash bigint(20) DEFAULT '0' NOT NULL,</tt>
<br><tt>&nbsp; ns bigint(20) DEFAULT '0' NOT NULL,</tt>
<br><tt>&nbsp; name varchar(254) DEFAULT '' NOT NULL,</tt>
<br><tt>&nbsp; PRIMARY KEY (hash)</tt>
<br><tt>);</tt>
</p><p><tt>CREATE TABLE namespaces (</tt>
<br><tt>&nbsp; hash bigint(20) DEFAULT '0' NOT NULL,</tt>
<br><tt>&nbsp; value varchar(254) DEFAULT '' NOT NULL,</tt>
<br><tt>&nbsp; PRIMARY KEY (hash)</tt>
<br><tt>);</tt>
</p><p><tt>CREATE TABLE literals (</tt>
<br><tt>&nbsp; hash bigint(20) DEFAULT '0' NOT NULL,</tt>
<br><tt>&nbsp; value longtext NOT NULL,</tt>
<br><tt>&nbsp; PRIMARY KEY (hash)</tt>
<br><tt>);</tt>
</p><p><tt>CREATE TABLE models (</tt>
<br><tt>&nbsp; id bigint(20) DEFAULT '0' NOT NULL,</tt>
<br><tt>&nbsp; uri varchar(254) DEFAULT '' NOT NULL,</tt>
<br><tt>&nbsp; size int(11),</tt>
<br><tt>&nbsp; PRIMARY KEY (id)</tt>
<br><tt>);</tt></p></td>
</tr>

<tr valign="TOP">
<td>Usage:</td>

<td>A query selecting all triples with the given (precomputed) subject,
predicate and object looks like this:
<p><tt>SELECT m.uri, t.objtype, concat(n1.value,r1.name) as subj,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; concat(n2.value,r2.name) as
pred, concat(n3.value,r3.name), l.value</tt>
<br><tt>FROM triples t, models m, resources r1, resources r2, namespaces
n1, namespaces n2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; LEFT JOIN literals l ON t.object=l.hash</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; LEFT JOIN resources r3 ON t.object=r3.hash</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; LEFT JOIN namespaces n3 ON r3.ns=n3.hash</tt>
<br><tt>WHERE t.subject=r1.hash AND r1.ns=n1.hash AND t.predicate=r2.hash
AND</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r2.ns=n2.hash AND m.id=t.model AND</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.subject=XXX AND t.predicate=YYY
AND t.object==ZZZ</tt></p></td>
</tr>

</tbody></table>

<h3>
To-be-named</h3>

<table border="" cellpadding="5">
<tbody><tr valign="TOP">
<td>To be contributed by:</td>

<td><a href="mailto:eric@tux.w3.org">Eric Prudhomeux</a></td>
</tr>

<tr valign="TOP">
<td>Brief summary:</td>

<td>"Clever mappings into SQL. Algernon-based query language that is rewritten
into SQL query or into in-memory
<br>graph queries."</td>
</tr>

<tr valign="TOP">
<td>Database schema:</td>

<td></td>
</tr>

</tbody></table>

<h3>
<a name="naive"></a>The naive approach</h3>

<table border="" cellpadding="5">
<tbody><tr valign="TOP">
<td>Contributed by:</td>

<td><a href="mailto:emiller@oclc.org">Eric Miller</a></td>
</tr>

<tr valign="TOP">
<td>Brief summary:</td>

<td>This is probably the simplest way of dealing with RDF one could think
of. Naive doesn't mean bad. Many applications that need a simple RDF store
could do with this solution.</td>
</tr>

<tr valign="TOP">
<td>Database schema:</td>

<td><tt>CREATE TABLE triple (</tt>
<br><tt>&nbsp; property varchar(255),</tt>
<br><tt>&nbsp; resource varchar(255),</tt>
<br><tt>&nbsp; value blob,</tt>
<br><tt>&nbsp; hint char(1)</tt>
<br><tt>);</tt></td>
</tr>

</tbody></table>



<h3>
If you have an RDBMS solution for your RDF data, please <a href="mailto:www-rdf-interest@w3.org">contribute</a>!</h3>

<hr width="100%">
<br><small>
<a href="mailto:melnik@db.stanford.edu">Sergey Melnik</a>, May 11, 2000
<br>Last modified: Dec 3, 2001


</small></body></html>